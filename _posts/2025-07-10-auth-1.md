---
layout: post
title: ""
subtitle: ""
tags: ["system-design"]
readtime: true
---

Imagine Samantha is building a blog. In the beginning, she decides to keep it simple and just serve HTML, CSS, and JavaScript files. The posts she writes are simple markdown files stored on the server's disk.

After 1-2 years, her blog takes off and now she want to monetize it. She decides on a membership model where she will allow a blog reader to be in one of the following two tiers:
- Economy Tier: Readers can create an account on her website and they'll get access to some of the posts written by Samantha
- Premium Tier: Readers can choose to pay a small monthly or yearly subscription fee and in return they'll get access to a all of Samantha's posts

For this, Samantha now has to modify her blog such that readers can have their own personal accounts. Also, her blog's backend should be able to figure out which tier the reader is a part of, so they only see the posts for that tier. Let's look at a traditional but still popular way of achieving this: Session based authentication.

## Session Bassed Authentication

Samantha wants her readers to be able to:
- Register on her website
- Login into their accounts
- Stay logged in, that is, they don't have to re-enter their credentials if they revisit her blog 5 minutes later
- Allow a reader to only see posts that they're allowed to.

Essentially, she wants to set up an authentication mechanism to recognize who the reader is and an authorization mechanism to show them the posts they're allowed to read.

Samantha first creates a registeration page and a login page. She also sets up a backend service, let's say `blog_svc`, to handle the login and registeration. 

TLS tightens the security for the messages sent by the browser to a backend. But it's a network layer security protocol and not an application layer security protocol. Thus, to protect the passwords of her readers, she sets up the front end such that the actual password will never be sent to `blog_svc` directly either during login or registeration. Rather, the password will be hashed in the browser itself and then sent to the backend. She also sets up a `readers_db` database that holds information about each reader, like `reader_id`, `reader_email`, `reader_name`, `hashed_password`, and `reader_tier`. At this point, this is just a CSV file on the disk of her server.

With this basic setup, readers are able to create accounts and login into their accounts. But, when a reader moves to a different page on the blog, they have to login again. This is because the browser makes an altogether new request to `blog_svc` and there's no way for the service to know who the reader is. This means that unless the reader's login credentials are sent with every request to `blog_svc`, the backend can't recognize the reader and thus, it can't tell if the reader is permissioned to view the page they want to visit. 

No one wants this. She doesn't want the reader to re-enter their credentials everytime they move to a different page or they close the tab and come back later to her blog. She wants to maintain some state that helps the backend authenticate the reader. This is what sessions help her achieve.

She modifies the backend to send a cookie with the response to the browser when a reader logs in. The cookie will hold a `session_id`, generated by the backend to be unique across all sessions and all readers. With every request, the browsers are set up to send all cookies they have recieved from the backend back to the backend. Thus, when a reader moves to a different page on her blog, the browser will send the cookie it recieved when the reader logged in.

Let's look at some of the fields Samantha configures in this cookie:
1. `name`: Name of the cookie. She sets it to be `session_id`
2. `value`: Value of the cookie. She sets it to a unique string generated by `blog_svc`.
3. `max-age`: Expiration duration of the cookie. The cookie will be deleted by the browser after that. She sets it to 48 hours.
4. `httpOnly`: This parameters controls if the cookie can be accessed by the website's JavaScript. Setting this to to True means that the cookie can't be read by the JS of the webpage, thus protecting the cookie from XSS atacks. 

  > Definition: XSS is a type of attack where bad code, usually JavaScript, is added to a website. This can happen if a site shows user input (like comments or search terms) without checking it properly. An attacker might post a comment with hidden code. When other people visit the page, their browsers run that code without knowing it's bad. This can let the attacker steal info or control parts of the site as if they were the user.

  Samantha sets it to True for protection of cookie from XSS attacks. This only prevents JavaScript from reading or stealing the cookie. So, XSS canâ€™t grab the cookie and send it elsewhere, but it can still make requests that include the cookie automatically. 
5. `secure`: This parameter allows the browser to send the cookie over HTTPS only. Samantha sets this to True for ensuring network level security.
6. `samesite`:  Controls cross-site request behavior (`Strict`, `Lax`, or `None`):
  - `Strict`: The cookie will only be sent when the request is generated by the reader themselves while interacting with the website on the browser.
  - `Lax`: The cookie can be sent when the reader gets redirected to her blog from another website, like an email link. The cookie will only be sent with non-modifying requests though, like `GET` or `HEAD`.
  - `None`: All requests, whether direct or not, will have the cookie, which is very unsafe, as it means an attacker can send requests to her backend on behalf of the reader, by making the reader click on redirect links.

  Samantha sets `samesite` to `Lax` so that she can send the newly published posts to her readers and on clicking the link, the readers get redirected to their account on her blog with the post opened.


She maintains an in-memory hash map, let's say `active_sessions_map`, of all the active sessions and the readers for which the session was created, that is, a mapping of `session_id` to `reader_id`. Just like the `max-age` parameter, she configures a TTL for all keys in this hash map as well, which is the same as the value she sets for `max-age` in the cookies. This will prevent her hash map to grow indefinitely large with time.

Now, when a reader moves to a different page on her blog or comes back to her website after a while or gets redirected to it, the browser sends the cookie (if it hasn't expired) to the backend with the request. The `blog_svc` service extracts the `session_id` from the cookie and looks up the `reader_id` associated with that `session_id`. It then fetches metadata about the reader from the `readers_db` database and knows if the reader is a member of the economy tier or the premium tier.

## Scaling Up

This system works for quite some time until the traffic on Samantha's blog increases even more. Her single server backend crumbles to handle more requests and the disk is almost full with all the posts and `reader_db` file has grown quite big. So she makes the following modifications:
1. She sets up two databases, `posts_db` to store her posts and `readers_db` to store metadata about her readers.
2. She also sets up multiple replicas of `blog_svc` and puts them behind a load balancer. The load balancer also shields the `blog_svc` from DDoS attacks by rate limiting requests from a particular client. It also checks for malformed requests and only forwards correct requests to the backend replicas.

> Definition: DDoS (Distributed Denial of Service) attacks involve overwhelming a server with traffic from multiple sources to make it unavailable.

Now, she encounters an issue: The `active_sessions_map` is different for all replicas of `blog_svc` as it is an in-memory map. This means that if the load balancer sends the login request to replica A, which generates a `session_id` for the reader, sends it back to the browser in a cookie, but the browser sends the next request from the reader to replica B, replica B has no clue about which reader is this `session_id` linked to or is it even a valid `session_id`.

Some options to handle this:
- Sticky Sessions: Make the load balancer forward all requests from a particular reader to the same replica. But what if the replica goes down? Then the readers managed by the replica aget logged out as the `active_sessions_map` on that replica is lost forever. Also, the load balancer will have to rebalance the distribution of readers on the active replicas if any replica goes down. For this, Samatha will need to configure the load balancer with a rebalance strategy that minimizes the disruption to already logged in readers on rebalance.
- Make the load balancer handle the authentication and the authorization. Once it knows the reader is valid and what tier they are a member of, the load balancer will forward the request to `blog_svc` with this extra information. But what if load balancer itself goes down? Even if we have stand by replicas of load balancers, all readers get logged out.
- Set up a centralized key value store, let's call it `active_sessions_store`, that stores the `session_id` to `reader_id` mapping for all active sessions across the replicas of `blog_svc`. This would make `blog_svc` stateless, which means that the active sessions of the readers are unaffected if the load balancer or a replica of `blog_svc` goes down. But this also means that, all replicas of `blog_svc` reach out to the same KV store, which can put heavy load on `active_sessions_store`.

Samantha decides to go with the third option and sets up KV store. Now, her blog has achieved tight security from certain application layer attacks. Her DBs are still SPOF, but she can create read replicas for those as well if needed. Is there anything still that can be improved? With central session store, revoking sessions instantly is harder due to network call from `blog_svc` to `active_sessions_store` and replica lag (revoking sessions ia a critical operation which should be done in a synchronous way to maintain strong consistency).

> Definition: Replica lag is the delay between when data is written to the primary database and when it appears on the read replicas.

Is there a way that `blog_svc` doesn't have to reach out to `active_sessions_store` for validating a `session_id`? Also, if a cookie is compromised somehow, the attacker has a long window (the cookie's `max-age` value is set to 48 hours) to use the compromised cookie to do anything they want on Samantha's blog? In the next post, we will look at how JSON Web Tokens help evade this two limitations.

This was all for session based authorization. 




