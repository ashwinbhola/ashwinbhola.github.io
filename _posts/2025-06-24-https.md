---
layout: post
title: "HTTPS"
subtitle: ""
tags: ["system-design"]
readtime: true
---

Internet = messages from your machine travel over many routers, ISPs, international cables. With HTTP data travels unprotected (imagine transparent and unsealed postal mail envelopes) => Anyone on this travel route can potentially read your data (you don't know how many prying eyes are there over the network), tamper it in transit (e.g., inject malware), pretend to be the website you're visiting (phishing)


TLS: Security protocol that protects data when it moves over internet
Without TLS: Transparent mail letter -- anyone watching the road can look inside the envelopes (your credit card info, emails, login credentials)

3 guarantees of TLS:
1. Confidentiality == Encryption (so no one else can read it): It scrambles (encryptes) your data in a way that only the intended reciever can unscramble (decrypt) it
With TLS: Your postal letter is locked in a box that only the reciever has the key for
TLS does two types of encryption: symmetric and asymmetric

2. Integrity (so it can't be altered in transit): TLS ensures that if somone is able to change your message, it would be detected
It does this using a cryptographic checksum, called a MAC or AEAD tag, to verify that the message wasn’t changed.
It's like putting a wax seal on your letter, if someone opened it on the way, you know someone tampered with it

3. Authentication (so you can be sure that you're not talking to an imposter): TLS checks the website's ID badge -- it's a digitial certificate issued by a Certificate Authority (CA)
Your browser checks that the certificate is issued and signed by a trusted CA, belongs to the domain you're visitng, and is hasn't expired. 

HTTPS is HTTP over TLS i.e. the same HTTP request but encrypted, protected, and verified by TLS. HTTPS runs on port 443 instead of the HTTP port 80.

How TLS works (TLS 1.3 to be specific):

The TLS handshake is the initial conversation between a client (like your browser) and a server (like https://example.com) before secure communication begins. It's main goal is to the let the 2 machines: prove who they are, agree on a secret key (to be used for encryption), and make sure no one can fake, repeat, or spy on this conversation. 

TLS 1.3 is a 3 step handshake, with the following steps:

1. ClientHello (Client -> Server)
Client generates a temporary key pair (1 private key, 1 public key) using elliptic curve math. It sends the generated public key, encryption styles (cipher suites) it supports, the latest TLS version it supports, a random number (we'll see where it is used). All of this is unencrypted.

2. ServerHello + Encrypted Handshake (Server -> Client)
2.1 ServerHello:
The server also generates a temporary key pair (1 private key, 1 public key) and replies to the client with the temporary public key, a chosen cipher suites (from the ones sent by the client), another random number. Nothing is encrypted here as well.

2.2. Deriving Handhsake Keys: 
Both client and server use Ephemeral Diffie-Hellman (usually ECDHE) algorithm on (their private key + the other’s public key) to compute a secret seed (asymmetric cryptography). The genius of ECDHE algorithm is that both side arrive at the same seed, without ever sending it directly. Even if if somone watched all the messages exchanged till now (as they weren't secure), they can't generate the secret seed generated by the client and the server as the private keys were not exchanged at all. 
Now that both sides have the same secret seed, they feed it into a key factory (a function called HKDF) to generate a bunch of encryption (each for a different purpose). HKDF takes in the secret seed, context info (e.g., the hash of the handshake transcript until now), and context label (e.g., `tls13 finished`) to generate an encryption key. In this step, 2 keys are generated:
- Client handshake traffic key: Generated using the context label `tls13 c hs traffic`. Used for encrypting and decrypting client -> server messages
- Server handshake traffic key: Generated using the context label `tls13 s hs traffic`. Used for encrypting and decrypting server -> client messages
Both sides generate both these keys.

2.3. Encrypted Handshake Phase Begins:
The server now encrypts the following using the "Server handshake traffic key" and sends it the client:
- Digital certificate: A TLS certificate is the digital passport of a website. Just like passports, it's issued by organizations called Certificate Authorities. The TLS certificate helps with authentication (helps a browser know who it is talking to) and trust (makes sure that it is not being tricked by a fake website). The TLS certificate includes the domain name, public key of the website, validity period, issuer (CA), and a digital signature (official stamp from the CA). The digital signature is encrypted by the CA's private key and can be decrypted by the browser using the CA's public key (Browsers have the public keys of trusted CAs inbuilt in them). 
- CertificateVerify: A digital signature encrypted using the server's private key. This can be decrypted using the public key of the sever in the certificate
- Finished message: A MAC (Machine Auhentication Code), which is computed using a "Finished" key. The "Finished" key is generated by the server using HKDF on `server_handshake_traffic_secret` and the hash of entire handshake transcript till now.

3.  Finish (Client → Server)
3.1 Client verifies the server's Identity:
The client decrypts the recieved messages using the "Server handshake traffic key". The browser checks the server's digital certificate: is it still valid, was it signed by a trusted CA, does it match the domain name of the server, is the digital signature of the CA valid. The browser also verifies the server's signature, which proves to the browser that the server does indeed own its private key. The client also verifies the `Finished` message by computing the expected MAC (computed by first generating a `Finished` key using the handshake transcript as the context and the `server_handshake_traffic_secret` key) and comparing it to the MAC sent by the server. 

If anything is wrong here, the TLS connection is immediately aborted, and the browser shows a security error like "Connection not secure". 

3.2 Client sends Finished:
If all checks go fine, the client sends its own `Finished` message which is a MAC generated by the client using the `client_handshake_traffic_secret` and the entire handshake transcript. The client needs to verify the server’s identity (via certificate & signature) before trusting it, and only after the client trusts the sever, it sends a "Finished" message to prove to the server that it has the correct secrets and trust the server.


Now that the handshake is complete, both sides derive new encryption keys, called the application traffic keys, using the same secret seed, but with different labels:
- client_application_traffic_key: For encrypting and decrypting the messages from client -> server
- server_application_traffic_key: For encrypting and decrypting the messages from server -> client

Going forward, everything will be encrypted and decrypted using these keys. Thus, TLS 1.3 uses asymmetric cryptography during the handshake only (before creating the secret seed). Once that’s done, it switches to symmetric encryption (the same key used for encryption is usef dor decrypting the message) for all actual communication.

Even though the TCP handshake technically involves 1.5 round trips, it is called 1-RTT handshake because:
- After the second flight (server to flight), both client and the server have the necessary ingridients to generate the encryption keys
- Any request by the client will piggyback on the "Finished" message from client to server, which means the 3rd flight is not actually blocking data transfer

More types of keys that TLS 1.3 uses:
- Resumption Key: TLS 1.3 allows the browser to resume a session without repeating the full handshake, by sending a resumption master secret (a temporary one-time use only pass that only works if the browser comes back soon). From that, the server generates a resumption key that lets the browser connect quickly and securely.
- Key Update Keys: TLS 1.3 allows key updates during long lived sessions, generating new application traffic keys periodically for extra security.

### Session Resumption in TLS 1.3

When you visit a website over HTTPS, the browser and server go through a full TLS handshake — exchanging keys, verifying identities, and setting up encryption. This takes a little time. If you connect soon after, TLS session resumption lets you reuse some earlier information to speed up the handshake, thus saving time, computing power, and bandwidth. How it works:
1. After a handshake finishes, the server feeds the secret seed (generated using the ECDHE algorithm) into the HKDF function to generate a PSK (Pre-Shared Key). The server then packages the PSK into a NewSessionTicket message. This packing/ encryption of the PSK by the server is done using an internal, symmetric key that only the server knows. This NewSessionTicket tagged with a ticket_id (PSK identity) is encrypted by the server using the application traffic keys and then sent to the client as a separate post-handshake message. The client decrypts the recieved message to find the NewSessionTicket and the tagged PSK identity in it but it can't decrypt the NewSessionTicket -- it stores this ticket and the PSK identity for future connections.
2. When the client connects later, the client sends a ClientHello message to server. In this message, it sends all the data it sends in the full handshake ClientHello message but also includes (in the pre_shared_key field of the ClientHello message) the PSK identity it recieved earlier. Client can include multiple PSK identities recieved earlier from the server.
3. Server inspects the ClientHello message and identifies the presence of the pre_shared_key extension. It inspects the PSK identities in it and does a thorough validation of each. If any of the PSK identities is still valid 


Whats the point of so much randomness?
1. Unique secret keys for every session: Any new session between the server and the client means a new generated secret seed. Thus, hackers can't reuse previous communication to predict the secret key that'll be generated the next time
2. No Replay Attacks: A replay attack is when an attacker captures a previous handshake or message and resends it later to trick the server. Imagine a hacker trying to log in your GMail account by repeating the conservation you had with Google's servers yesterday. The hacker can't do that now as the Google's server will generate a new ephemeral (public key, private key) pair for this session. This means that the secret seed and the resulting encryption keys generated will be different today, so the server will reject the encrypted login credentials (or any messages from previous session) sent yesterday. In fact, the attack will fail even earlier, during the handshake, because the final "Finished" message, which proves both sides derived the same key, won’t match, and the server will abort the connection.
3. Forward Secrecy: The encryption keys generated are created on the fly and are never stored. This ensures that every secure session stays private forever (nothing exists that can be stolen tomorrow). It’s like burning both the key and the lock - no one can recreate the lock or the key afterward.
4. Newness in Resumed Sessions: TLS 1.3 even adds randomness when you resume a session i.e. the client and server don’t reuse the exact same keys as before, so it’s still secure





