---
layout: post
title: "HTTPS"
subtitle: ""
tags: ["system-design"]
readtime: true
---

On the internet, messages from your device travel through many routers, ISPs, and international cables. With HTTP, data travels unprotected. It's like sending a transparent and unsealed envelope through the mail - and you can imagine how many prying eyes might take a peek. When you send sensitive information online (like credit card details or login credentials), you don't want anyone on the route to read your data, or tamper with it (for example, by injecting malware), or pretend to be the website you're visiting (phishing). While HTTP doesn't prevent any of these from happening, HTTPS uses a security protocol that protects communication between your browser and servers worldwide. This security protocol is called TLS (Transport Layer Security), and it protects your data when it moves across the internet.

HTTPS is essentially HTTP over TLS - that is, the same HTTP request but encrypted, protected, and verified using TLS. HTTPS uses port 443 instead of the HTTP port 80. In the OSI model, TLS sits between the application layer and the transport layer. Think of TLS as a security guard standing between your app and the network. It secures HTTP data sent by applications (in the application layer) before passing it to the web server working at the transport layer. TLS effectively provides three key guarantees:
1. Confidentiality: TLS scrambles (encrypts) your data in a way that only the intended recipient can unscramble (decrypt) it. In a real world analogy, TLS locks your letter in a box and only the intended recipient has the key.
2. Integrity: TLS ensures that your data can't be changed in transit and if someone tries, it would be detected. It’s like sealing your letter with wax - if it’s broken, you know it was tampered with.
3. Authentication: To make sure that you're not sending sensitive information to an imposter, TLS verifies the website's digital certificate (like an ID badge).

There are two commonly used types of encryption:
1. Symmetric Encryption: Imagine locking your letter in a box that can be locked and unlocked with the same key. Both the sender and the recipient own a copy of this key.
2. Asymmetric Encryption: Imagine locking a box with one key, but needing a different key to unlock it. The sender uses a locking key, and only the recipient has the correct key to open it.

In this post, we'll focus on TLS 1.3 - the latest and most secure version of the protocol. While TLS 1.3 offers the most security, its adoption is still ongoing, and older versions of TLS, like TLS 1.2, are still widely used. 

## How TLS works (TLS 1.3 to be specific):

The TLS handshake is the initial conversation between a client (like your browser) and a server (like https://example.com) before secure communication begins. It's main goal is to the let the 2 machines: prove who they are, agree on a secret key (to be used for encryption), and make sure no one can fake, repeat, or spy on this conversation. 

TLS 1.3 is a 3 step handshake, with the following steps:

1. ClientHello (Client -> Server)
Client generates a temporary key pair (1 private key, 1 public key) using elliptic curve math. It sends the generated public key, encryption styles (cipher suites) it supports, the latest TLS version it supports, a random number (we'll see where it is used). All of this is unencrypted.

2. ServerHello + Encrypted Handshake (Server -> Client)
2.1 ServerHello:
The server also generates a temporary key pair (1 private key, 1 public key) and replies to the client with the temporary public key, a chosen cipher suites (from the ones sent by the client), another random number. Nothing is encrypted here as well.

2.2. Deriving Handhsake Keys: 
Both client and server use Ephemeral Diffie-Hellman (usually ECDHE) algorithm on (their private key + the other’s public key) to compute a secret seed (asymmetric cryptography). The genius of ECDHE algorithm is that both side arrive at the same seed, without ever sending it directly. Even if if somone watched all the messages exchanged till now (as they weren't secure), they can't generate the secret seed generated by the client and the server as the private keys were not exchanged at all. 
Now that both sides have the same secret seed, they feed it into a key factory (a function called HKDF) to generate a bunch of encryption (each for a different purpose). HKDF takes in the secret seed, context info (e.g., the hash of the handshake transcript until now), and context label (e.g., `tls13 finished`) to generate an encryption key. In this step, 2 keys are generated:
- Client handshake traffic key: Generated using the context label `tls13 c hs traffic`. Used for encrypting and decrypting client -> server messages
- Server handshake traffic key: Generated using the context label `tls13 s hs traffic`. Used for encrypting and decrypting server -> client messages
Both sides generate both these keys.

2.3. Encrypted Handshake Phase Begins:
The server now encrypts the following using the "Server handshake traffic key" and sends it the client:
- Digital certificate: A TLS certificate is the digital passport of a website. Just like passports, it's issued by organizations called Certificate Authorities. The TLS certificate helps with authentication (helps a browser know who it is talking to) and trust (makes sure that it is not being tricked by a fake website). The TLS certificate includes the domain name, public key of the website, validity period, issuer (CA), and a digital signature (official stamp from the CA). The digital signature is encrypted by the CA's private key and can be decrypted by the browser using the CA's public key (Browsers have the public keys of trusted CAs inbuilt in them). 
- CertificateVerify: A digital signature encrypted using the server's private key. This can be decrypted using the public key of the sever in the certificate
- Finished message: A MAC (Machine Auhentication Code), which is computed using a "Finished" key. The "Finished" key is generated by the server using HKDF on `server_handshake_traffic_secret` and the hash of entire handshake transcript till now.

3.  Finish (Client → Server)
3.1 Client verifies the server's Identity:
The client decrypts the recieved messages using the "Server handshake traffic key". The browser checks the server's digital certificate: is it still valid, was it signed by a trusted CA, does it match the domain name of the server, is the digital signature of the CA valid. The browser also verifies the server's signature, which proves to the browser that the server does indeed own its private key. The client also verifies the `Finished` message by computing the expected MAC (computed by first generating a `Finished` key using the handshake transcript as the context and the `server_handshake_traffic_secret` key) and comparing it to the MAC sent by the server. 

If anything is wrong here, the TLS connection is immediately aborted, and the browser shows a security error like "Connection not secure". 

3.2 Client sends Finished:
If all checks go fine, the client sends its own `Finished` message which is a MAC generated by the client using the `client_handshake_traffic_secret` and the entire handshake transcript. The client needs to verify the server’s identity (via certificate & signature) before trusting it, and only after the client trusts the sever, it sends a "Finished" message to prove to the server that it has the correct secrets and trust the server.


Now that the handshake is complete, both sides derive new encryption keys, called the application traffic keys, using the same secret seed, but with different labels:
- client_application_traffic_key: For encrypting and decrypting the messages from client -> server
- server_application_traffic_key: For encrypting and decrypting the messages from server -> client

Going forward, everything will be encrypted and decrypted using these keys. Thus, TLS 1.3 uses asymmetric cryptography during the handshake only (before creating the secret seed). Once that’s done, it switches to symmetric encryption (the same key used for encryption is usef dor decrypting the message) for all actual communication.

Even though the TCP handshake technically involves 1.5 round trips, it is called 1-RTT handshake because:
- After the second flight (server to flight), both client and the server have the necessary ingridients to generate the encryption keys
- Any request by the client will piggyback on the "Finished" message from client to server, which means the 3rd flight is not actually blocking data transfer

More types of keys that TLS 1.3 uses:
- Resumption Key: TLS 1.3 allows the browser to resume a session without repeating the full handshake, by sending a resumption master secret (a temporary one-time use only pass that only works if the browser comes back soon). From that, the server generates a resumption key that lets the browser connect quickly and securely.
- Key Update Keys: TLS 1.3 allows key updates during long lived sessions, generating new application traffic keys periodically for extra security.

### Whats the point of so much randomness?
1. Unique secret keys for every session: Any new session between the server and the client means a new generated secret seed. Thus, hackers can't reuse previous communication to predict the secret key that'll be generated the next time
2. No Replay Attacks: A replay attack is when an attacker captures a previous handshake or message and resends it later to trick the server. Imagine a hacker trying to log in your GMail account by repeating the conservation you had with Google's servers yesterday. The hacker can't do that now as the Google's server will generate a new ephemeral (public key, private key) pair for this session. This means that the secret seed and the resulting encryption keys generated will be different today, so the server will reject the encrypted login credentials (or any messages from previous session) sent yesterday. In fact, the attack will fail even earlier, during the handshake, because the final "Finished" message, which proves both sides derived the same key, won’t match, and the server will abort the connection.
3. Forward Secrecy: The encryption keys generated are created on the fly and are never stored. This ensures that every secure session stays private forever (nothing exists that can be stolen tomorrow). It’s like burning both the key and the lock - no one can recreate the lock or the key afterward.
4. Newness in Resumed Sessions: TLS 1.3 even adds randomness when you resume a session i.e. the client and server don’t reuse the exact same keys as before, so it’s still secure

### Session Resumption in TLS 1.3

When you visit a website over HTTPS, the browser and server go through a full TLS 1.3 handshake — exchanging keys, verifying identities, and setting up encryption. This takes a little time. If you connect soon after, TLS session resumption lets you skip parts of that handshake, saving time, computing power, and bandwidth, but also not sacrificing on security. How it works:

1. Issuing the Session Ticket
After a full handshake finishes, both client and server derive a `resumption master secret` from the HKDF function using their secret code. The server uses this to derive a `resumption_psk` PSK (Pre-Shared Key), again using the HKDF function. The server then creates a NewSessionTicket message containing the following information:
- `ticket`: Holds the PSK (Opaque to the client)
- `ticket_lifetime`
- `ticket_age_add`
- `ticket_nonce`
- `ticket_id` (Unique ID for this NewSessionTicket message)

The NewSessionTicket is sent post-handshake, encrypted using application traffic keys. The client receives and decrypts the message but it doesn't decrypt the `ticket` yet. Instead it stores `ticket_id` and the `ticket` mainly for future use.

2. Reconnecting with PSK + Binder
When the client reconnects to the server, it sends a ClientHello message, just like it would in a full handshake (including a new public key derived using elliptic curve math). But this time, it includes a `pre_shared_key` extension, containing:
- One or more PSK identities (ticket IDs from earlier sessions)
- Corresponding binders (One per PSK)

For every PSK identity (`resumption_psk`), the client computes a binder using the **current** ClientHello transcript hash (`transcript_hash`):
```
early_secret_seed = HKDF(salt=0, resumption_psk)
binder_key = HKDF(early_secret_seed, "resumption binder", "", num_bytes_output)
binder = HMAC(binder_key, transcript_hash)
```
This is a proof from the client that it has the PSK tied to the ticket.

3. Server Verifies the Binder and Accepts
The server receives the ClientHello and checks for the `pre_shared_key` extension. It examines each PSK identity in order of client preference. For each PSK:
- Locates the associated session ticket (if it still has it)
- Decrypts and verifies the ticket (authenticity, expiration, etc.)
- Uses the `resumption_psk` it posesses for the `ticket_id` being checked to generate a binder itself. This generated binder is matched with the binder recieved from the client. If the binder match, this tells the server that the client does indeed possess the PSK.

If a valid PSK is found, the server selects it and sends back a ServerHello message containing:
- the index of the accepted PSK identity from the list the client sent
- a new public key derived using the elliptic curve math

No certificate is sent as the client is assumed to already trust the server from the earlier handshake.

4. PSK + ECDHE Key Derivation and Completion
Both client and server now have:
- Their own ephemeral public and private keys
- The other side's ephemeral public key
- Selected PSK

Both sides now derive the a fresh secret seed using their own private key, other's side public key, and the selected PSK (this happens in multiple steps and is not a 3-way combo). This secret seed is then used to a generate new set of Application Traffic Keys, Finished keys, Handshake Traffic Keys etc. TFollowing the ServerHello, the server will send a Finished message encrypted using the newly generated  handshake traffic keys. The client responds with its Finished message and can now immediately start sending encrypted application data.





